# Computer Architecture
- 시스템 해킹의 기술은 컴퓨터 과학에 뿌리를 두고 있다. 이 파일에는 컴퓨터 과학의 넓은 분야 중에서  
  강의를 이해하고 문제를 푸는데에 꼭 필요한 가장 기초적인 내용만을 정리한다.

# Overview
- Computer Architecture - Von Neumann Architecture
- Instruction Set Architecture - x86-64 Architecture
- x86-64 Register
- General Register
- Segment Register
- Instruction Pointer Register
- Flag Register
- Register Compatibility

## Computer Architecture
- 컴퓨터 구조는 컴퓨터가 효율적으로 작동할 수 있도록 하드웨어 및 소프트웨어의 기능을 고안하고, 이들을 구성하는 방법이다.
- 컴퓨터 구조는 컴퓨터의 기능 구조에 대한 설계, 명령어 집합구조, 마이크로 아키텍쳐, 그리고  
  기타 하드웨어 및 컴퓨팅 방법에 대한 설계 등을 포함한다.  
  
  I. **컴퓨터의 기능 구조에 대한 설계**
  	- 컴퓨터가 연산을 효율적으로 하기 위해 어떤 기능들이 컴퓨터에 필요한지 고민하고  
      설계하는 분야로, 대표적으로 폰 노이만 구조, 하버드 구조, 수정된 하버드 구조가 있다.  
       
  II. **명령어 집합구조**
  	- CPU가 처리해야하는 명령어를 설계하는 분야로, 대표적으로 ARM, MIPS, AVR, 인텔의 x86 및 x86-64 등이 있다.  
  
  III. **마이크로 아키텍쳐**
  	- 정의된 명령어 집합을 효율적으로 처리할 수 있도록 CPU의 회로를 설계하는 분야이다.

- 컴퓨터 구조
  - 기능 구조의 설계
    - 폰 노이만 구조 +
    - 하버드 구조
    - 수정된 하버드 구조

  - 명령어 집합구조
    - x86, x86-64 + 
    - ARM
    - MIPS
    - AVR

  - 마이크로 아키텍쳐
    - 캐시 설계
    - 파이프라이닝
    - 슈퍼 스칼라
    - 분기 예측
    - 비순차적 명령어 처리

  - 하드웨어 및 컴퓨팅 방법론
    - 직접 메모리 접근

### Von Neumann Architecture
- 초기 컴퓨터 과학자 중 한명인 폰 노이만은 컴퓨터에 연산, 제어, 저장의 세 가지 핵심 기능이 필요하다고 생각했다.  
  근대의 컴퓨터는 연산과 제어를 위해 CPU(중앙처리장치)를, 저장을 위해 memory(기억장치)를 사용하며,  
  장치간에 데이터나 제어 신호를 교환할 수 있도록 bus(버스)라는 전자 통로를 사용한다.
  
  I. **CPU**  
  - CPU는 프로그램의 연산을 처리하고 시스템을 관리한다. 프로세스의 코드를 불러오고, 실행하고, 결과를 저장하는  
    모든 과정이 CPU에서 일어난다. CPU는 산술/논리 연산을 처리하는 ALU(산술논리장치)와 CPU를 제어하는  
    Control Unit(제어장치), CPU에 필요한 데이터를 저장하는 Register(레지스터) 등으로 구성된다.  
    
  - CPU의 연산속도는 기억장치와의 데이터 교환속도보다 압도적으로 빠르기 때문에, 기억장치만을 사용하면 병목현상이 발생한다.  
    따라서 CPU는 교환속도를 획기적으로 단축하기 위해 레지스터와 캐시라는 저장장치를 내부에 갖고 있다.

  II. **memory**  
  - 기억장치는 컴퓨터가 동작하는데 필요한 여러 데이터를 저장하기 위해 사용되며, 용도에 따라 주기억장치와 보조기억장치로 분류된다.  
    주기억장치는 프로그램 실행과정에서 필요한 데이터들을 임시로 저장하기 위해 사용되며, 대표적으로 RAM(램)이 있다.  
    이와 반대로 보조기억장치는 운영 체제, 프로그램 등과 같은 데이터를 장기간 보관하고자 할 때 사용되며, 대표적으로  
    HDD(하드 드라이브), SSD가 있다.

  III. **bus**  
  - 버스는 컴퓨터 부품과 부품 사이 또는 컴퓨터와 컴퓨터 사이에 신호를 전송하는 통로를 말한다. 대표적으로 데이터가 이동하는  
    Data Bus(데이터 버스), 주소를 지정하는 Address Bus(주소 버스), 읽기/쓰기를 제어하는 Control Bus(제어 버스)가 있다.  
    이 외에도 랜선이나 데이터 전송 소프트웨어, 프로토콜 등도 버스라고 한다.

## Instruction Set Architecture
- ISA(명령어 집합 구조)는 CPU가 해석하는 명령어의 집합이다.
- ISA는 IA-32, x86-64(x64), MIPS, AVR 등 컴퓨터의 용도에 따라 다양하게 존재한다.
- x86-64는 고성능 프로세서를 설계하기 위해 사용되며, 데스크톱 또는 랩톱에 적합하다.
- x86 기반 CPU의 점유율이 압도적으로 많고 가장 범용적이다.  

### x86-64 Architecture
- 1999년, AMD는 인텔의 32비트 CPU 아키텍처인 IA-32를 64비트로 확장한 AMD64 아키텍처를 발표하였다.  
  AMD64가 시장에서 널리 인정받자, 인텔을 비롯한 다양한 회사에서 이를 기반으로 다양한 이름의  
  아키텍처를 발표하기 시작했다. 이 과정에서 범용적이고 중립적으로 지칭되는 x86-64라는 명칭이  
  만들어졌고, 현재 대다수 개인용 컴퓨터는 이 x86-64 아키텍처 기반의 CPU를 탑재하고 있다.
- **(Intel64, IA-32e, EM64T, amd64) ∈ x86-64 (x64)**  
- n 비트 아키텍처에서 n은 CPU가 한번에 처리할 수 있는 최대 데이터의 크기이다. 컴퓨터 과학에서는  
  이를 CPU가 이해할 수 있는 데이터의 단위라는 의미에서 **WORD**라고 부른다. **WORD**의 크기는  
  CPU가 어떻게 설계됐느냐에 따라 달라진다.

## x86-64 Register
- 레지스터는 CPU가 데이터를 빠르게 저장하고 사용할 때 이용하는 장소로, 산술 연산에 필요한 데이터를
  저장하거나 주소를 저장하고 참조하는 등 다양한 용도로 사용된다. x86-64 아키텍처에는
  **General Register(범용 레지스터)**, **Segment Register(세그먼트 레지스터)**,
  **Instruction Pointer Register-IP(명령어 포인터 레지스터)**, **Flag Register(플래그 레지스터)** 가 존재한다.

### General Register
- 범용 레지스터는 주용도는 있으나, 그 외의 다양한 용도로 사용될 수 있는 레지스터이다. x86-64에서 각각의 범용 레지스터는
  8바이트를 저장할 수 있고, 부호 없는 정수를 기준으로 $2^{64} - 1$ 까지의 수를 나타낼 수 있다.
- 자주 쓰이는 범용 레지스터들의 주용도는 다음과 같다. 이 외에도 x64에는 r8, r9,..., r15까지의 범용 레지스터가 더 존재한다.  

  | 이름 | 주용도 |
  | :---: | :---: |
  | rax (accumulator register) | 함수의 반환 값 |
  | rbx (base register) | x64에서는 주된 용도 없음 |
  | rcx (counter register) | 반복문의 반복 횟수, 각종 연산의 시행 횟수 |
  | rdx (data register) | x64에서는 주된 용도 없음 |
  | rsi (source index) | 데이터를 옮길 때 원본을 가리키는 포인터 |
  | rdi (destination index) | 데이터를 옮길 때 목적지를 가리키는 포인터 |
  | rsp (stack pointer) | 사용중인 스택의 위치를 가리키는 포인터 |
  | rbp (stack base pointer) | 스택의 바닥을 가리키는 포인터 |  

### Segment Register
- x64 아키텍처에는 **cs, ss, ds, es, fs, gs** 총 6가지 세그먼트 레지스터가 존재하며, 각 레지스터의 크기는 16비트이다.  
- 세그먼트 레지스터는 x64로 아키텍처가 확장되면서 용도에 큰 변화가 생겼는데, 현대의 x64에서  
  cs, ds, ss 레지스터는 코드 영역과 데이터, 스택 메모리 영역을 가리킬 떄 사용되고,  
  나머지 레지스터는 운영체제 별로 용도를 결정할 수 있도록 범용적으로 사용된다.

### Instruction Pointer Register
- 프로그램은 일련의 기계어 코드들로 이루어져 있다. 이 중에서 CPU가 어느 부분의 코드를 실행할지  
  가리키는 것이 명령어 포인터 레지스터의 역할이다. x64 아키텍처의 명령어 레지스터는 **rip**이며,  
  크기는 8바이트이다.

### Flag Register
- 플래그 레지스터는 프로세서의 현재 상태를 저장하고 있는 레지스터이다.
- x64 아키텍처에서는 **RFLAGS**라고 불리는 64비트 크기의 플래그 레지스터가 존재하는데,  
  플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현한다.
- RFLAGS는 64비트이므로 최대 64개의 플래그를 사용할 수 있지만, 실제로는 20여개의 비트만 사용한다.  
  그 중, 주로 접하게 될 것은 다음과 같다.

  | 플래그 | 의미 |
  | :---: | :---: |
  | CF (Carry Flag) | 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정한다. |
  | ZF (Zero Flag) | 연산의 결과가 0일 경우 설정한다. |
  | SF (Sign Flag) | 연산의 결과가 음수일 경우 설정한다. |
  | OF (Overflow Flag)) | 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정한다. |

### Register Compatibility
- x86-64 아키텍처는 IA-32의 64비트 확장 아키텍처이며, 호환이 가능하다.
- IA-32에서 CPU의 레지스터들은 32비트 크기를 가지며, 이들의 명칭은 각각
  eax, ebx, ecx, edx, esi, edi, esp, ebp 이다.
- rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp 가 이들의 확장된 형태이며,
  eax, ebx 등은 확장된 레지스터의 하위 32비트를 가리킨다.
- 마찬가지로, 과거 IA-16과의 호환을 위해 ax, bx, cx, dx, si, di, sp, bp는
  eax, ebx, ecx, edx, esi, edi, esp, ebp의 하위 16비트를 가리킨다.
- 이들 중 몇몇은 다시 상위 8비트, 하위 8비트로 나뉜다.
  



  
			









