# Return to Library

## Program
익스플로잇 대상 프로그램은 다음과 같다.

```c
// Name: rtl.c
// Compile: gcc -o rtl rtl.c -fno-PIE -no-pie

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

const char* binsh = "/bin/sh";

int main() {
  char buf[0x30];

  setvbuf(stdin, 0, _IONBF, 0);
  setvbuf(stdout, 0, _IONBF, 0);

  system("echo 'system@plt'");

  printf("[1] Leak Canary\n");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);

  printf("[2] Overwrite return address\n");
  printf("Buf: ");
  read(0, buf, 0x100);

  return 0;
}
```

[Return to Library](https://dreamhack.io/wargame/challenges/353)

## Analysis
```bash
(checksec 분석)
```

checksec로 rtl에 적용된 보호 기법을 확인 하였다. 실습 환경 및 최신 리눅스 커널에서 ASLR은 기본으로 적용되어 있으므로, 특별히 언급되지 않는다면 ASLR은 적용된 것이다.

```c
const char* binsh = "/bin/sh";
```

위의 코드는 "/bin/sh" 문자열의 시작 주소를 가리키는 char형 포인터 변수 binsh를 정의한다. 그런데, const는 프로그램을 실행하는 동안 변수의 값이 바뀔 수 없도록 만든다. 따라서 binsh변수와 "/bin/sh" 문자열 모두 Data Segment의 rodata영역에 위치하며, ASLR 보호 기법의 영향을 받지 않는다.

```c
char buf[0x30];
```

main()에서 선언된 지역 변수는 0x30 크기의 char형 배열 하나뿐이다. 지역 변수의 배치 순서를 확인할 필요는 없지만, Padding이 있을 수 있기 때문에 바이너리를 분석할 때에는 반드시 gdb를 사용하여 직접 필요한 정보를 수집해야 한다.

```asm
(gdb 분석)
```

실제로, 위의 분석 결과를 보면 buf와 Canary 사이에 8바이트의 Padding이 존재한다.

```c
system("echo 'system@plt'");
```

위의 코드는 system()을 call하여 GOT에 실제 system()의 메모리 주소를 저장하고 두 번째 system() call 부터 system()에 바로 접근할 수 있도록 한다. (system()을 프로그램에서 처음 call 할 경우 PLT는 GOT에 쓰여진 주소로 jmp 한다. 이 때, GOT에는 실제 system()의 주소가 아닌 동적 링커의 주소가 쓰여져있는데, 동적 링커는 runtime resolve를 수행하여 system()의 실제 주소를 라이브러리에서 찾고 이를 GOT에 기록한다. 따라서, 두 번째 실행부터는 PLT가 GOT를 참조할 때, GOT에 system()의 주소가 쓰여져있으므로, runtime resolve를 수행할 필요 없이 바로 system()으로 jmp할 수 있다.)

```c
printf("[1] Leak Canary\n");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);
```

위의 코드는 Canary 우회를 위해서 존재한다. Canary는 buf와 SFP 사이에 존재하는데, 랜덤한 8바이트 값을 사용하여 초기의 Canary 값과 함수가 끝나기 직전에 Canary 값을 비교하는 방법으로 Stack Buffer Overflow를 방지한다.


























