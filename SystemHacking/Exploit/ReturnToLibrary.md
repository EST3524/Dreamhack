# Return to Library

## Program
익스플로잇 대상 프로그램은 다음과 같다.

```c
// Name: rtl.c
// Compile: gcc -o rtl rtl.c -fno-PIE -no-pie

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

const char* binsh = "/bin/sh";

int main() {
  char buf[0x30];

  setvbuf(stdin, 0, _IONBF, 0);
  setvbuf(stdout, 0, _IONBF, 0);

  system("echo 'system@plt'");

  printf("[1] Leak Canary\n");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);

  printf("[2] Overwrite return address\n");
  printf("Buf: ");
  read(0, buf, 0x100);

  return 0;
}
```

[Return to Library](https://dreamhack.io/wargame/challenges/353)

## Analysis
```bash
(checksec 분석)
```

checksec로 rtl에 적용된 보호 기법을 확인 하였다. 실습 환경 및 최신 리눅스 커널에서 ASLR은 기본으로 적용되어 있으므로, 특별히 언급되지 않는다면 ASLR은 적용된 것이다.

```c
const char* binsh = "/bin/sh";
```

위의 코드는 "/bin/sh" 문자열의 시작 주소를 가리키는 char형 포인터 변수 binsh를 정의한다. 그런데, const는 프로그램을 실행하는 동안 변수의 값이 바뀔 수 없도록 만든다. 따라서 binsh변수와 "/bin/sh" 문자열 모두 Data Segment의 rodata영역에 위치하며, ASLR 보호 기법의 영향을 받지 않는다.

```c
char buf[0x30];
```

main()에서 선언된 지역 변수는 0x30 크기의 char형 배열 하나뿐이다. 지역 변수의 배치 순서를 확인할 필요는 없지만, Padding이 있을 수 있기 때문에 바이너리를 분석할 때에는 반드시 gdb를 사용하여 직접 필요한 정보를 수집해야 한다.

```asm
(gdb 분석)
```

실제로, 위의 분석 결과를 보면 buf와 Canary 사이에 8바이트의 Padding이 존재한다.

```c
system("echo 'system@plt'");
```

위의 코드는 system()을 call하여 GOT에 실제 system()의 메모리 주소를 저장하고 두 번째 system() call 부터 system()에 바로 접근할 수 있도록 한다.  

system()을 프로그램에서 처음 call 할 경우 PLT는 GOT에 쓰여진 주소로 jmp 한다. 이 때, GOT에는 실제 system()의 주소가 아닌 동적 링커의 주소가 쓰여져있는데, 동적 링커는 runtime resolve를 수행하여 system()의 실제 주소를 라이브러리에서 찾고 이를 GOT에 기록한다. 따라서, 두 번째 실행부터는 PLT가 GOT를 참조할 때, GOT에 system()의 주소가 쓰여져있으므로, runtime resolve를 수행할 필요 없이 바로 system()으로 jmp할 수 있다.

```c
printf("[1] Leak Canary\n");
printf("Buf: ");
read(0, buf, 0x100);
printf("Buf: %s\n", buf);
```

위의 코드는 첫 번째 단계로, Canary 우회를 위해서 존재한다. Canary는 buf와 SFP 사이에 존재하는데, 프로그램 실행 초기에 생성한 Canary 값과 함수가 끝나기 직전에 Canary 값을 비교하는 방법으로 Stack Buffer Overflow가 발생했는지 확인한다.

```c
printf("[2] Overwrite return address\n");
printf("Buf: ");
read(0, buf, 0x100);
```

위의 코드는 두 번째 단계로, 최종적으로 Return to Library 공격 기법을 사용하여 익스플로잇을 수행하도록 하기 위해 존재한다.

## Exploit
익스플로잇에 활용할 수 있는 취약점은 다음과 같다. 

1. /bin/sh 문자열이 rodata 영역에 존재하며, 이는 ASLR 보호 기법의 영향을 받지 않는다.

2. system()의 실제 주소가 이미 GOT에 기록되어 있으며, PLT, GOT는 각각 Code Segment, Data Segment에 위치하기 때문에 ASLR의 영향을 받지 않는다.

3. 1, 2번 단계에서 buf의 크기인 0x30 바이트를 넘어서 read 함수가 0x100 바이트만큼 입력받기 때문에 Stack Buffer Overflow를 이용하여 Canary Leak, Return Address 							          Overwrite 를 수행할 수 있다.

바이너리의 스택 구조는 다음 표와 같다.

| Low Address |
| :---: |
| buf : 0x30 |
| Padding : 0x8 |
| SFP : 0x8 |
| ret : 0x8 |
| High  Address |
















